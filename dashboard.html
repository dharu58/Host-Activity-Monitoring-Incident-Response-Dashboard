<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Server Performance Dashboard</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: 'Arial', sans-serif; background-color: #2c3e50; color: #ecf0f1; margin: 0; padding: 20px; }
        .container { max-width: 1600px; margin: auto; }
        h1 { border-bottom: 2px solid #34495e; padding-bottom: 10px; }
        .controls { background-color: #34495e; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .controls label, .controls select, .controls input, .controls button { margin-right: 15px; color: #ecf0f1; border: none; padding: 5px; border-radius: 3px; }
        .controls input[type="number"] { background-color: #2c3e50; color: #ecf0f1; }
        .controls select { background-color: #2c3e50; color: #ecf0f1; }
        .controls button { background-color: #2ecc71; cursor: pointer; }
        /* Expanded Grid to fit 4 columns for a richer dashboard */
        .grid-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 20px; }
        .chart-panel { 
            background-color: #34495e; 
            padding: 20px; 
            border-radius: 5px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
            height: 350px; 
            grid-column: span 1; 
        }

        .chart-panel h2 { margin-top: 0; font-size: 1.2em; color: #ecf0f1; }
        canvas { max-width: 100%; height: 100%; }
        
        /* Style for the Processes list */
        #processes-display { list-style: none; padding: 0; margin-top: 10px; max-height: 250px; overflow-y: auto; }
        #processes-display li { background-color: #2c3e50; padding: 5px 10px; border-radius: 3px; margin-bottom: 3px; font-size: 0.9em; }
        .timestamp-header { font-weight: bold; color: #3498db; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Server Performance Dashboard</h1>

        <div class="controls">
            <label for="host-select">Select Host:</label>
            <select id="host-select"></select>
            
            <label for="time-range">Time Range (Last Hours):</label>
            <input type="number" id="time-range" value="1" min="1" max="24" style="width: 60px;">
            
            <button onclick="fetchData()">Refresh Data (Polling)</button>
        </div>

        <div class="grid-container">
            <!-- Row 1: Core Metrics (4 columns) -->
            <div class="chart-panel">
                <h2>CPU Utilization (%)</h2>
                <canvas id="cpuChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>RAM Load (%)</h2>
                <canvas id="memoryChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>Disk Utilization (%)</h2>
                <canvas id="diskChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>Total Processes</h2>
                <canvas id="processCountChart"></canvas>
            </div>
            
            <!-- Row 2: Bandwidth, IO, Load, and List (4 columns) -->
            <div class="chart-panel">
                <h2>Load Average (1, 5, 15 min)</h2>
                <canvas id="loadAvgChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>Network Bandwidth (Bytes/s)</h2>
                <canvas id="networkChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>I/O Throughput (Bytes/s)</h2>
                <canvas id="diskIOChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>Active Processes List</h2>
                <ul id="processes-display"></ul>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api';
        const hostSelect = document.getElementById('host-select');
        const timeRangeInput = document.getElementById('time-range');

        let cpuChart, memoryChart, diskChart, networkChart, diskIOChart, loadAvgChart, processCountChart;

        // --- Utility Function to get Bytes/s ---
        function calculateRate(data, key) {
            const rates = [];
            for (let i = 1; i < data.length; i++) {
                const current = data[i];
                const previous = data[i - 1];
                const timeDiffSeconds = (new Date(current.timestamp) - new Date(previous.timestamp)) / 1000;
                
                if (timeDiffSeconds > 0) {
                    const valueDiff = current[key] - previous[key];
                    rates.push({ 
                        x: new Date(current.timestamp), 
                        y: Math.max(0, valueDiff / timeDiffSeconds)
                    });
                }
            }
            return rates;
        }

        // --- 1. Chart Initialization ---
        function createChart(ctx, label, colors = ['#e74c3c'], fill = false, max = 100) {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                        ticks: { color: '#bdc3c7' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        title: { display: true, text: label.includes('(') ? label.substring(label.indexOf('(')+1, label.indexOf(')')) : label },
                        min: 0,
                        max: max,
                        ticks: { color: '#bdc3c7' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: { legend: { display: colors.length > 1 } },
                color: '#ecf0f1'
            };
            
            const datasets = colors.map((color, index) => ({
                label: label.split(',')[index]?.trim() || label,
                data: [],
                borderColor: color,
                backgroundColor: fill ? `${color}33` : color,
                fill: fill,
                tension: 0.3,
                borderWidth: 2
            }));

            return new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: chartOptions
            });
        }

        function initCharts() {
            // Destroy existing charts
            [cpuChart, memoryChart, diskChart, networkChart, diskIOChart, loadAvgChart, processCountChart].forEach(chart => {
                if (chart) chart.destroy();
            });

            // Initialize all charts
            cpuChart = createChart(document.getElementById('cpuChart').getContext('2d'), 'CPU Utilization (%)', ['#e74c3c']);
            memoryChart = createChart(document.getElementById('memoryChart').getContext('2d'), 'RAM Load (%)', ['#3498db'], true);
            diskChart = createChart(document.getElementById('diskChart').getContext('2d'), 'Disk Utilization (%)', ['#9b59b6'], true);
            processCountChart = createChart(document.getElementById('processCountChart').getContext('2d'), 'Total Processes', ['#f1c40f'], false, undefined);
            
            // Multi-line charts
            loadAvgChart = createChart(document.getElementById('loadAvgChart').getContext('2d'), '1 min, 5 min, 15 min Load', ['#e74c3c', '#f39c12', '#3498db'], false, undefined);
            networkChart = createChart(document.getElementById('networkChart').getContext('2d'), 'Sent, Received (Bytes/s)', ['#1abc9c', '#f39c12'], false, undefined);
            diskIOChart = createChart(document.getElementById('diskIOChart').getContext('2d'), 'Read, Write (Bytes/s)', ['#e67e22', '#34495e'], false, undefined);
        }
        
        // --- 2. Host List Initialization (Same as before) ---
        async function fetchHosts() {
            try {
                const response = await fetch(`${API_BASE}/hosts`);
                const data = await response.json();
                
                hostSelect.innerHTML = ''; 

                if (data.hosts && data.hosts.length > 0) {
                    data.hosts.forEach(host => {
                        const option = document.createElement('option');
                        option.value = host;
                        option.textContent = host;
                        hostSelect.appendChild(option);
                    });
                    initCharts(); 
                    fetchData(); 
                } else {
                    console.error('No hosts found. Ensure agents are running and ingesting data.');
                }

            } catch (error) {
                console.error('Error fetching hosts:', error);
            }
        }

        // --- 3. Data Fetching and Chart Rendering ---
        async function fetchData() {
            const hostId = hostSelect.value;
            if (!hostId) return;

            const hours = parseInt(timeRangeInput.value) || 1;
            const now = new Date();
            const startTime = new Date(now.getTime() - hours * 60 * 60 * 1000).toISOString();

            try {
                const metricsUrl = `${API_BASE}/metrics/${hostId}?start_time=${startTime}&limit=100`;
                const metricsResponse = await fetch(metricsUrl);
                const metricsData = await metricsResponse.json();
                updateCharts(metricsData);
            } catch (error) {
                console.error('Error fetching metrics:', error);
            }

            try {
                const processesResponse = await fetch(`${API_BASE}/processes/${hostId}`);
                const processesData = await processesResponse.json();
                displayProcesses(processesData);
            } catch (error) {
                console.error('Error fetching processes:', error);
            }
        }

        function updateCharts(metrics) {
            const sortedMetrics = metrics.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            if (sortedMetrics.length === 0) return;

            // --- Single Line Charts ---
            const cpuData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.cpu }));
            const memoryData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.memory }));
            const diskUsageData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.disk?.usage_percent || 0 }));
            const processCountData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.process_count || 0 }));

            cpuChart.data.datasets[0].data = cpuData;
            memoryChart.data.datasets[0].data = memoryData;
            diskChart.data.datasets[0].data = diskUsageData;
            processCountChart.data.datasets[0].data = processCountData;

            // --- Load Average (Multi-line Chart) ---
            const load1min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['1min'] || 0 }));
            const load5min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['5min'] || 0 }));
            const load15min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['15min'] || 0 }));
            
            loadAvgChart.data.datasets[0].data = load1min;
            loadAvgChart.data.datasets[1].data = load5min;
            loadAvgChart.data.datasets[2].data = load15min;


            // --- Network Bandwidth (Rate of Change) ---
            const networkMetrics = sortedMetrics
                .filter(m => m.network)
                .map(m => ({ timestamp: m.timestamp, bytes_sent: m.network.bytes_sent, bytes_recv: m.network.bytes_recv }));

            const sentRate = calculateRate(networkMetrics, 'bytes_sent');
            const recvRate = calculateRate(networkMetrics, 'bytes_recv');

            networkChart.data.datasets[0].data = sentRate;
            networkChart.data.datasets[1].data = recvRate;
            
            // --- Disk I/O (Rate of Change) ---
            const diskIOMetrics = sortedMetrics
                .filter(m => m.disk)
                .map(m => ({ timestamp: m.timestamp, read_bytes: m.disk.read_bytes, write_bytes: m.disk.write_bytes }));

            const readRate = calculateRate(diskIOMetrics, 'read_bytes');
            const writeRate = calculateRate(diskIOMetrics, 'write_bytes');
            
            diskIOChart.data.datasets[0].data = readRate;
            diskIOChart.data.datasets[1].data = writeRate;


            // Update all charts
            cpuChart.update();
            memoryChart.update();
            diskChart.update();
            processCountChart.update();
            loadAvgChart.update();
            networkChart.update();
            diskIOChart.update();
        }

        function displayProcesses(data) {
            const processesDisplay = document.getElementById('processes-display');
            processesDisplay.innerHTML = ''; 

            if (data.processes && data.processes.length > 0) {
                const header = document.createElement('li');
                header.className = 'timestamp-header';
                header.textContent = `Latest check: ${new Date(data.timestamp).toLocaleTimeString()} (Total: ${data.process_count})`;
                processesDisplay.appendChild(header);

                const uniqueProcesses = [...new Set(data.processes)].slice(0, 15);
                uniqueProcesses.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = p;
                    processesDisplay.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'No process data available.';
                processesDisplay.appendChild(li);
            }
        }
        
        // Start the application
        fetchHosts();

        // Automatic polling for near real-time updates (every 15 seconds)
        setInterval(() => {
            const hostId = hostSelect.value;
            if (hostId) {
                fetchData();
            }
        }, 15000);
    </script>
</body>
</html>
