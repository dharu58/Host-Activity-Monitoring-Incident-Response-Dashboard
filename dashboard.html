<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Server Performance Dashboard</title>
    <!-- Include Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        body { font-family: 'Arial', sans-serif; background-color: #2c3e50; color: #ecf0f1; margin: 0; padding: 20px; }
        .container { max-width: 1600px; margin: auto; }
        h1 { border-bottom: 2px solid #34495e; padding-bottom: 10px; }
        .controls { background-color: #34495e; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .controls label, .controls select, .controls input, .controls button { margin-right: 15px; color: #ecf0f1; border: none; padding: 5px; border-radius: 3px; }
        .controls input[type="number"] { background-color: #2c3e50; color: #ecf0f1; }
        .controls select { background-color: #2c3e50; color: #ecf0f1; }
        .controls button { background-color: #2ecc71; cursor: pointer; }
        /* Expanded Grid to fit 4 columns for a richer dashboard */
        .grid-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 20px; }
        .chart-panel { 
            background-color: #34495e; 
            padding: 20px; 
            border-radius: 5px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2); 
            height: 350px; 
            grid-column: span 1; 
        }

        .chart-panel h2 { margin-top: 0; font-size: 1.2em; color: #ecf0f1; }
        canvas { max-width: 100%; height: 100%; }
        
        /* Style for the Processes list */
        #processes-display { list-style: none; padding: 0; margin-top: 10px; max-height: 250px; overflow-y: auto; }
        #processes-display li { background-color: #2c3e50; padding: 5px 10px; border-radius: 3px; margin-bottom: 3px; font-size: 0.9em; }
        .timestamp-header { font-weight: bold; color: #3498db; }
        /* ADD: Alerts styling - place at end of existing <style> */
#alerts-container {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 320px;
    z-index: 9999;
    display: flex;
    flex-direction: column;
    gap: 12px;
    pointer-events: none; /* let clicks pass except for buttons */
}

.alert-card {
    pointer-events: auto;
    background: #e74c3c; /* red */
    color: #ffffff;
    padding: 12px 14px;
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    font-family: Arial, sans-serif;
    line-height: 1.1;
}

.alert-content {
    flex: 1 1 auto;
    font-size: 13px;
}

.alert-title {
    font-weight: 700;
    margin-bottom: 4px;
    font-size: 13px;
}

.alert-meta {
    font-size: 12px;
    opacity: 0.95;
}

.alert-ok {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.9);
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 700;
    font-size: 12px;
}

    </style>
</head>
<body>
    <div class="container">
    <div id="alerts-container" aria-live="polite"></div>

        <h1>Server Performance Dashboard</h1>

        <div class="controls">
            <label for="host-select">Select Host:</label>
            <select id="host-select"></select>
            
            <label for="time-range">Time Range (Last Hours):</label>
            <input type="number" id="time-range" value="1" min="1" max="24" style="width: 60px;">
            
            <button onclick="fetchData()">Refresh Data (Polling)</button>
        </div>

        <div class="grid-container">
            <!-- Row 1: Core Metrics (4 columns) -->
            <div class="chart-panel">
                <h2>CPU Utilization (%)</h2>
                <canvas id="cpuChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>RAM Load (%)</h2>
                <canvas id="memoryChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>Disk Utilization (%)</h2>
                <canvas id="diskChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>Total Processes</h2>
                <canvas id="processCountChart"></canvas>
            </div>
            
            <!-- Row 2: Bandwidth, IO, Load, and List (4 columns) -->
            <div class="chart-panel">
                <h2>Load Average (1, 5, 15 min)</h2>
                <canvas id="loadAvgChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>Network Bandwidth (Bytes/s)</h2>
                <canvas id="networkChart"></canvas>
            </div>
            
            <div class="chart-panel">
                <h2>I/O Throughput (Bytes/s)</h2>
                <canvas id="diskIOChart"></canvas>
            </div>

            <div class="chart-panel">
                <h2>Active Processes List</h2>
                <ul id="processes-display"></ul>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8000/api';
        const hostSelect = document.getElementById('host-select');
        const timeRangeInput = document.getElementById('time-range');

        let cpuChart, memoryChart, diskChart, networkChart, diskIOChart, loadAvgChart, processCountChart;

const SIMULATE_ALERTS = false;


const activeAlerts = new Map();

function makeAlertKey(host, metric) {
    return `${host}::${metric}`;
}

function showAlert({ host, metric, value, severity = 'P2', timestamp = new Date().toISOString(), message = '' }) {
    const key = makeAlertKey(host, metric);
    if (activeAlerts.has(key)) return; // already shown
    activeAlerts.set(key, true);

    const container = document.getElementById('alerts-container');
    if (!container) return;

    const card = document.createElement('div');
    card.className = 'alert-card';
    card.dataset.alertKey = key;

    const content = document.createElement('div');
    content.className = 'alert-content';
    content.innerHTML = `<div class="alert-title">${severity} — ${metric}</div>
                         <div class="alert-meta">host: ${host} · ${value} · ${new Date(timestamp).toLocaleString()}</div>
                         ${message ? `<div class="alert-meta">${message}</div>` : ''}`;

    const ok = document.createElement('button');
    ok.className = 'alert-ok';
    ok.textContent = 'OK';
    ok.onclick = () => dismissAlert(key, card);

    card.appendChild(content);
    card.appendChild(ok);
    container.prepend(card);
}

function dismissAlert(key, cardElem) {
    if (cardElem && cardElem.remove) cardElem.remove();
    activeAlerts.delete(key);
}


function evaluateAlertCondition(host, metric, value, severity, message) {
    showAlert({ host, metric, value, severity, message });
}


function createSimulatedAlerts() {

    showAlert({ host: 'SimHost-0', metric: 'disk.usage_percent', value: '93%', severity: 'P1', message: 'Disk critical' });
    showAlert({ host: 'SimHost-1', metric: 'cpu', value: '92%', severity: 'P2', message: 'Sustained high CPU' });
    showAlert({ host: 'SimHost-2', metric: 'agent_heartbeat', value: 'no data', severity: 'P1', message: 'No heartbeat > 2m' });
}

        // --- Utility Function to get Bytes/s ---
        function calculateRate(data, key) {
            const rates = [];
            for (let i = 1; i < data.length; i++) {
                const current = data[i];
                const previous = data[i - 1];
                const timeDiffSeconds = (new Date(current.timestamp) - new Date(previous.timestamp)) / 1000;
                
                if (timeDiffSeconds > 0) {
                    const valueDiff = current[key] - previous[key];
                    rates.push({ 
                        x: new Date(current.timestamp), 
                        y: Math.max(0, valueDiff / timeDiffSeconds)
                    });
                }
            }
            return rates;
        }

        // --- 1. Chart Initialization ---
        function createChart(ctx, label, colors = ['#e74c3c'], fill = false, max = 100) {
            const chartOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'time',
                        time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
                        ticks: { color: '#bdc3c7' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    },
                    y: {
                        title: { display: true, text: label.includes('(') ? label.substring(label.indexOf('(')+1, label.indexOf(')')) : label },
                        min: 0,
                        max: max,
                        ticks: { color: '#bdc3c7' },
                        grid: { color: 'rgba(255, 255, 255, 0.1)' }
                    }
                },
                plugins: { legend: { display: colors.length > 1 } },
                color: '#ecf0f1'
            };
            
            const datasets = colors.map((color, index) => ({
                label: label.split(',')[index]?.trim() || label,
                data: [],
                borderColor: color,
                backgroundColor: fill ? `${color}33` : color,
                fill: fill,
                tension: 0.3,
                borderWidth: 2
            }));

            return new Chart(ctx, {
                type: 'line',
                data: { datasets: datasets },
                options: chartOptions
            });
        }

        function initCharts() {
            // Destroy existing charts
            [cpuChart, memoryChart, diskChart, networkChart, diskIOChart, loadAvgChart, processCountChart].forEach(chart => {
                if (chart) chart.destroy();
            });

            // Initialize all charts
            cpuChart = createChart(document.getElementById('cpuChart').getContext('2d'), 'CPU Utilization (%)', ['#e74c3c']);
            memoryChart = createChart(document.getElementById('memoryChart').getContext('2d'), 'RAM Load (%)', ['#3498db'], true);
            diskChart = createChart(document.getElementById('diskChart').getContext('2d'), 'Disk Utilization (%)', ['#9b59b6'], true);
            processCountChart = createChart(document.getElementById('processCountChart').getContext('2d'), 'Total Processes', ['#f1c40f'], false, undefined);
            
            // Multi-line charts
            loadAvgChart = createChart(document.getElementById('loadAvgChart').getContext('2d'), '1 min, 5 min, 15 min Load', ['#e74c3c', '#f39c12', '#3498db'], false, undefined);
            networkChart = createChart(document.getElementById('networkChart').getContext('2d'), 'Sent, Received (Bytes/s)', ['#1abc9c', '#f39c12'], false, undefined);
            diskIOChart = createChart(document.getElementById('diskIOChart').getContext('2d'), 'Read, Write (Bytes/s)', ['#e67e22', '#34495e'], false, undefined);
        }
        // ADD: Kick off simulation alerts if requested
if (SIMULATE_ALERTS) {
    // create an initial batch and repeat every 20s to let you test stacking/dismiss
    createSimulatedAlerts();
    setInterval(() => createSimulatedAlerts(), 20000);
}

        
        // --- 2. Host List Initialization (Same as before) ---
        async function fetchHosts() {
            try {
                const response = await fetch(`${API_BASE}/hosts`);
                const data = await response.json();
                
                hostSelect.innerHTML = ''; 

                if (data.hosts && data.hosts.length > 0) {
                    data.hosts.forEach(host => {
                        const option = document.createElement('option');
                        option.value = host;
                        option.textContent = host;
                        hostSelect.appendChild(option);
                    });
                    initCharts(); 
                    fetchData(); 
                } else {
                    console.error('No hosts found. Ensure agents are running and ingesting data.');
                }

            } catch (error) {
                console.error('Error fetching hosts:', error);
            }
        }

        // --- 3. Data Fetching and Chart Rendering ---
        async function fetchData() {
            const hostId = hostSelect.value;
            if (!hostId) return;

            const hours = parseInt(timeRangeInput.value) || 1;
            const now = new Date();
            const startTime = new Date(now.getTime() - hours * 60 * 60 * 1000).toISOString();

            try {
                const metricsUrl = `${API_BASE}/metrics/${hostId}?start_time=${startTime}&limit=100`;
                const metricsResponse = await fetch(metricsUrl);
                const metricsData = await metricsResponse.json();
                updateCharts(metricsData);

            } catch (error) {
                console.error('Error fetching metrics:', error);
            }
            // CALL: Evaluate alerts after charts update (paste right after updateCharts(metricsData);)
try {
    // pass a sorted array in chronological order to evaluator
    const sortedForEval = metricsData.sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
    evaluateAlertsForMetrics(sortedForEval);
} catch (e) {
    console.error('Alert evaluation error:', e);
}

            try {
                const processesResponse = await fetch(`${API_BASE}/processes/${hostId}`);
                const processesData = await processesResponse.json();
                displayProcesses(processesData);
            } catch (error) {
                console.error('Error fetching processes:', error);
            }
        }

        function updateCharts(metrics) {
            const sortedMetrics = metrics.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            if (sortedMetrics.length === 0) return;

            // --- Single Line Charts ---
            const cpuData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.cpu }));
            const memoryData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.memory }));
            const diskUsageData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.disk?.usage_percent || 0 }));
            const processCountData = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.process_count || 0 }));

            cpuChart.data.datasets[0].data = cpuData;
            memoryChart.data.datasets[0].data = memoryData;
            diskChart.data.datasets[0].data = diskUsageData;
            processCountChart.data.datasets[0].data = processCountData;

            // --- Load Average (Multi-line Chart) ---
            const load1min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['1min'] || 0 }));
            const load5min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['5min'] || 0 }));
            const load15min = sortedMetrics.map(m => ({ x: new Date(m.timestamp), y: m.load_average?.['15min'] || 0 }));
            
            loadAvgChart.data.datasets[0].data = load1min;
            loadAvgChart.data.datasets[1].data = load5min;
            loadAvgChart.data.datasets[2].data = load15min;


            // --- Network Bandwidth (Rate of Change) ---
            const networkMetrics = sortedMetrics
                .filter(m => m.network)
                .map(m => ({ timestamp: m.timestamp, bytes_sent: m.network.bytes_sent, bytes_recv: m.network.bytes_recv }));

            const sentRate = calculateRate(networkMetrics, 'bytes_sent');
            const recvRate = calculateRate(networkMetrics, 'bytes_recv');

            networkChart.data.datasets[0].data = sentRate;
            networkChart.data.datasets[1].data = recvRate;
            
            // --- Disk I/O (Rate of Change) ---
            const diskIOMetrics = sortedMetrics
                .filter(m => m.disk)
                .map(m => ({ timestamp: m.timestamp, read_bytes: m.disk.read_bytes, write_bytes: m.disk.write_bytes }));

            const readRate = calculateRate(diskIOMetrics, 'read_bytes');
            const writeRate = calculateRate(diskIOMetrics, 'write_bytes');
            
            diskIOChart.data.datasets[0].data = readRate;
            diskIOChart.data.datasets[1].data = writeRate;


            // Update all charts
            cpuChart.update();
            memoryChart.update();
            diskChart.update();
            processCountChart.update();
            loadAvgChart.update();
            networkChart.update();
            diskIOChart.update();
        }
        // ADD: Evaluator - minimal, uses recent metrics to decide alerts
function evaluateAlertsForMetrics(sortedMetrics) {
    if (!sortedMetrics || sortedMetrics.length === 0) return;

    // Use latest and short window where available
    const latest = sortedMetrics[sortedMetrics.length - 1];
    const host = latest.host_id || latest.host || hostSelect.value || 'unknown';

    // Disk usage immediate
    const diskUsage = latest.disk?.usage_percent ?? null;
    if (diskUsage !== null && diskUsage >= 90) {
        evaluateAlertCondition(host, 'disk.usage_percent', `${diskUsage}%`, 'P1', 'Disk usage >= 90%');
    }

    // Memory sustained: check last ~3 minutes (or last 3 samples)
    const memWindow = sortedMetrics.slice(-5); // best-effort window
    if (memWindow.length >= 1) {
        const memMin = Math.min(...memWindow.map(m => m.memory ?? 0));
        const memAllHigh = memWindow.every(m => (m.memory ?? 0) >= 90);
        if (memAllHigh && memMin >= 90) {
            evaluateAlertCondition(host, 'memory', `${memMin}%`, 'P1', 'Memory >= 90% for window');
        }
    }

    // CPU sustained: average over last ~5 samples
    const cpuWindow = sortedMetrics.slice(-10);
    if (cpuWindow.length >= 1) {
        const cpuAvg = cpuWindow.reduce((s, m) => s + (m.cpu ?? 0), 0) / cpuWindow.length;
        if (cpuAvg >= 85) {
            evaluateAlertCondition(host, 'cpu', `${cpuAvg.toFixed(1)}%`, 'P2', 'CPU avg >= 85% over window');
        }
    }

    // Load avg: compare 1min to 2x CPU cores (best-effort)
    const load1 = latest.load_average?.['1min'] ?? null;
    const cores = navigator.hardwareConcurrency || 1;
    if (load1 !== null && load1 >= cores * 2) {
        evaluateAlertCondition(host, 'load_average', `${load1}`, 'P2', `1min load >= ${cores * 2}`);
    }

    // Agent heartbeat: if timestamp older than 2 minutes
    const latestTime = new Date(latest.timestamp);
    if ((Date.now() - latestTime.getTime()) > 2 * 60 * 1000) {
        evaluateAlertCondition(host, 'agent_heartbeat', 'no recent data', 'P1', 'No metrics in >2 minutes');
    }

    // Process count sudden jump (simple heuristic): compare latest to previous
    if (sortedMetrics.length >= 2) {
        const prev = sortedMetrics[sortedMetrics.length - 2];
        const prevCount = prev.process_count || 0;
        const currCount = latest.process_count || 0;
        if (prevCount > 0 && currCount >= prevCount * 2 && (currCount - prevCount) > 10) {
            evaluateAlertCondition(host, 'process_count', `${currCount}`, 'P3', 'Process count > 2x previous');
        }
    }
}


        function displayProcesses(data) {
    <!--ZGhhcnVuaWtrYSBpcyBhIGJpdGNoIA==-->
            const processesDisplay = document.getElementById('processes-display');
            processesDisplay.innerHTML = ''; 

            if (data.processes && data.processes.length > 0) {
                const header = document.createElement('li');
                header.className = 'timestamp-header';
                header.textContent = `Latest check: ${new Date(data.timestamp).toLocaleTimeString()} (Total: ${data.process_count})`;
                processesDisplay.appendChild(header);

                const uniqueProcesses = [...new Set(data.processes)].slice(0, 15);
                uniqueProcesses.forEach(p => {
                    const li = document.createElement('li');
                    li.textContent = p;
                    processesDisplay.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'No process data available.';
                processesDisplay.appendChild(li);
            }
        }
        
        // Start the application
        fetchHosts();

        // Automatic polling for near real-time updates (every 15 seconds)
        setInterval(() => {
            const hostId = hostSelect.value;
            if (hostId) {
                fetchData();
            }
        }, 15000);
    </script>
</body>
</html>
